Accelerator Hooks

Background

Accelerator hooks are the mechanism for integrating custom accelerator
devices into PyTorch’s runtime.

Design

The tables below list the hooks accelerator vendors should implement
when integrating a new device backend. These hooks are categorized into
two priority levels:

- High‑priority hooks: Core APIs that the PyTorch runtime directly
  depends on. Vendors should implement all high‑priority hooks to ensure
  core compatibility and basic device functionality.

- Low‑priority hooks: Device‑management and utility APIs that PyTorch
  does not directly depend on. These hooks enhance user experience and
  multi‑device support and are optional. Vendors can implement them
  based on specific requirements and use cases.

High‑priority hooks

  --------------------------------------------------------------------------------------------
  Hook method                        Description             Application scenarios
  ---------------------------------- ----------------------- ---------------------------------
  init()                             Initializes the         Set up necessary state when
                                     accelerator runtime and PyTorch first accesses the device
                                     device contexts         

  hasPrimaryContext(DeviceIndex)     Checks if a primary     Determine whether device
                                     context exists for the  initialization has occurred
                                     device                  

  getDefaultGenerator(DeviceIndex)   Returns the default     Access the device’s primary RNG
                                     random number generator for reproducible random
                                     for a device            operations

  getNewGenerator(DeviceIndex)       Creates a new           Create isolated RNG instances for
                                     independent random      parallel operations
                                     number generator        

  getDeviceFromPtr(void*)            Determines which device Identify the accelerator device
                                     a memory pointer        associated with a memory
                                     belongs to              allocation

  getPinnedMemoryAllocator()         Returns an allocator    Allocate host memory that can be
                                     for pinned              efficiently transferred to/from
                                     (page-locked) host      the accelerator
                                     memory                  

  isPinnedPtr(void*)                 Checks if a pointer     Validate memory types before
                                     points to pinned memory performing operations
  --------------------------------------------------------------------------------------------

Low‑priority hooks

  ---------------------------------------------------------------------------------------------
  Hook method                        Description                    Application scenarios
  ---------------------------------- ------------------------------ ---------------------------
  isBuilt()                          Returns whether the            Check whether the
                                     accelerator backend is         accelerator library is
                                     built/compiled into the        available at compile time
                                     extension                      

  isAvailable()                      Returns whether the            Verify whether accelerator
                                     accelerator hardware is        devices can be detected and
                                     available at runtime           initialized

  deviceCount()                      Returns the number of          Enumerate all available
                                     available accelerator devices  accelerator devices for
                                                                    device selection

  setCurrentDevice(DeviceIndex)      Sets the active device for the Switch the current thread’s
                                     current thread                 context to a specific
                                                                    accelerator device

  getCurrentDevice()                 Returns the currently active   Query which accelerator
                                     device index                   device is active in the
                                                                    current thread

  exchangeDevice(DeviceIndex)        Atomically exchanges the       Temporarily switch devices
                                     current device and returns the and restore the previous
                                     previous one                   device afterward

  maybeExchangeDevice(DeviceIndex)   Conditionally exchanges device Safely attempt device
                                     only if the index is valid     switching with validation
  ---------------------------------------------------------------------------------------------

Implementation

For illustration, OpenReg (Open Registration) is a PyTorch integration
example that fills the gap for out‑of‑tree accelerator backend
integration. It demonstrates how vendors can register custom device
backends—without modifying PyTorch core—by implementing the hooks
interface (see at::PrivateUse1HooksInterface).

We use getDefaultGenerator as an example:

{eval-rst} .. literalinclude:: ../../../test/cpp_extensions/open_registration_extension/torch_openreg/csrc/runtime/OpenRegHooks.h     :language: c++     :start-after: LITERALINCLUDE START: OPENREG HOOK EXAMPLES     :end-before: LITERALINCLUDE END: OPENREG HOOK EXAMPLES     :linenos:

In this implementation:

1.  Override the base interface: The getDefaultGenerator method
    overrides the virtual method from at::PrivateUse1HooksInterface.

2.  Delegate to the device‑specific implementation: Call
    getDefaultOpenRegGenerator(device_index), which manages a per‑device
    generator instance.

3.  Return a device‑specific generator: The returned at::Generator wraps
    an OpenRegGeneratorImpl that implements device‑specific random
    number generation.

This pattern applies to all hooks: override the interface method,
validate inputs, delegate to your device‑specific API, and return
results in PyTorch’s expected format.

Integration Example

The following sections demonstrate how PyTorch integrates with
accelerator hooks when accessing the default random number generator.
The example traces the complete flow from user-facing Python code down
to the device-specific implementation.

Layer 1: User Code

User code sets a deterministic seed by calling manual_seed:

    import torch
    torch.openreg.manual_seed(42)

Layer 2: Extension Python API

The Python API layer manages device selection and calls into the C++
extension (defined in torch_openreg/openreg/random.py):

{eval-rst} .. literalinclude:: ../../../test/cpp_extensions/open_registration_extension/torch_openreg/torch_openreg/openreg/random.py     :language: python     :start-after: LITERALINCLUDE START: OPENREG MANUAL SEED     :end-before: LITERALINCLUDE END: OPENREG MANUAL SEED     :linenos:

The manual_seed function obtains the current device index, calls
torch_openreg._C._get_default_generator(idx) to get the device‑specific
generator, and sets its seed.

Layer 3: Python/C++ Bridge

The C++ extension exposes _getDefaultGenerator to Python, which bridges
into PyTorch core:

{eval-rst} .. literalinclude:: ../../../test/cpp_extensions/open_registration_extension/torch_openreg/torch_openreg/csrc/Module.cpp     :language: c++     :start-after: LITERALINCLUDE START: OPENREG GET DEFAULT GENERATOR     :end-before: LITERALINCLUDE END: OPENREG GET DEFAULT GENERATOR     :linenos:     :emphasize-lines: 10-11

{eval-rst} .. literalinclude:: ../../../test/cpp_extensions/open_registration_extension/torch_openreg/torch_openreg/csrc/Module.cpp     :language: c++     :start-after: LITERALINCLUDE START: OPENREG MODULE METHODS     :end-before: LITERALINCLUDE END: OPENREG MODULE METHODS     :linenos:     :emphasize-lines: 3

This function unpacks the device index from Python, creates a
PrivateUse1 device object, and calls
at::globalContext().defaultGenerator(). PyTorch’s context then
dispatches to the registered hooks.

Layer 4: PyTorch Core Context

PyTorch’s Context class dispatches to the appropriate accelerator hooks
(aten/src/ATen/Context.h):

{eval-rst} .. literalinclude:: ../../../aten/src/ATen/Context.h     :language: c++     :lines: 60-103     :linenos:     :emphasize-lines: 8-9, 24-25

This layered architecture keeps PyTorch device‑agnostic while delegating
hardware‑specific operations to accelerator implementations. Hooks are
registered once at module load time:

{eval-rst} .. literalinclude:: ../../../test/cpp_extensions/open_registration_extension/torch_openreg/csrc/runtime/OpenRegHooks.cpp     :language: c++     :start-after: LITERALINCLUDE START: OPENREG HOOK REGISTER     :end-before: LITERALINCLUDE END: OPENREG HOOK REGISTER     :linenos:     :emphasize-lines: 4

Layer 5: Accelerator Hooks

The hooks interface provides the abstraction PyTorch uses to delegate to
device‑specific implementations:

{eval-rst} .. literalinclude:: ../../../test/cpp_extensions/open_registration_extension/torch_openreg/csrc/runtime/OpenRegHooks.h     :language: c++     :start-after: LITERALINCLUDE START: OPENREG HOOK EXAMPLES     :end-before: LITERALINCLUDE END: OPENREG HOOK EXAMPLES     :linenos:

The getDefaultGenerator hook method overrides the base interface and
delegates to getDefaultOpenRegGenerator, which manages the actual
generator instances.

Layer 6: Device-Specific Implementation

The device‑specific implementation manages per‑device generator
instances:

{eval-rst} .. literalinclude:: ../../../test/cpp_extensions/open_registration_extension/torch_openreg/csrc/runtime/OpenRegGenerator.cpp     :language: c++     :start-after: LITERALINCLUDE START: OPENREG GET DEFAULT GENERATOR IMPL     :end-before: LITERALINCLUDE END: OPENREG GET DEFAULT GENERATOR IMPL     :linenos:

This function maintains a static vector of generators (one per device),
initializes them on first access, validates the device index, and
returns the appropriate generator instance.
